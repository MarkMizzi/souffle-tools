////// Grammar for the RAM programs generated by the compiler
// NOTE: This may change a lot from version to version, but worth having: we can distill all the information into plans.

program: "PROGRAM" declaration subroutine* main "END PROGRAM"

/// relation declarations

declaration: "DECLARATION" signature* "END DECLARATION"

signature: relation_signature | functor_signature

relation_signature: ram_relname "(" ( attribute ( "," attribute )* )? ")"
                    | ram_relname "nullary" // 0-arity relation?

functor_signature: userdef_functor "(" ( attribute ( "," attribute )* )? ")"

/// subroutines

subroutine: "SUBROUTINE" IDENT subroutine_stmt* "END SUBROUTINE"

?subroutine_stmt: loop_stmt | io_stmt | query_stmt | debug_stmt | clear_stmt | swap_stmt

loop_stmt: "LOOP" (subroutine_stmt | exit_stmt)+ "END LOOP"

io_stmt: "IO" qualified_name "("  io_option ("," io_option)*  ")"

io_option: IO_OPT_NAME "=" io_opt_value

?io_opt_value: "\"" IO_METHOD "\""
               | "\"" tab_list "\""
               | "\"" UNSIGNED "\""
               | STRING
               | "\"" qualified_name "\""
               | "\"" IO_OP "\""
               | "\"" json "\""

tab_list: IDENT ("\\t" IDENT)*

debug_stmt: "DEBUG" STRING query_stmt "END DEBUG"

query_stmt: "QUERY" ram_stmt "END QUERY"

clear_stmt: "CLEAR" ram_relname

swap_stmt: "SWAP" "(" ram_relname "," ram_relname ")"

exit_stmt: "EXIT" ram_cond

?ram_stmt: declare_stmt | forloop | if_stmt | insert_stmt | unpack_stmt

declare_stmt: tuple_element_ref "=" AGGREGATOR "FOR" "ALL" IDENT "IN" ram_relname ram_stmt

forloop: "FOR" IDENT "IN" ram_relname on_index? ram_stmt

if_stmt: "IF" ram_cond on_index? BREAK? ram_stmt

unpack_stmt: "UNPACK" IDENT "ARITY" NUMBER "FROM" tuple_element_ref ram_stmt

insert_stmt: "INSERT" tuple_expr "INTO" ram_relname

on_index: "ON" "INDEX" ram_cond

?ram_cond: ram_cond "WHERE" or_cond
           | or_cond

?or_cond: or_cond "OR" and_cond
          | and_cond

?and_cond: and_cond "AND" not_cond
           | not_cond

?not_cond: "NOT" atomic_cond -> not_cond
           | atomic_cond

?atomic_cond: in_cond
             | exists_cond
             | isempty_cond
             | comparision
             | bracketed_cond

in_cond: tuple_expr "IN" ram_relname

exists_cond: "EXISTS" IDENT "IN" ram_relname

isempty_cond: "ISEMPTY" "(" ram_relname ")"

comparision: tuple_element COMPARATOR tuple_element

bracketed_cond: "(" ram_cond ")"

tuple_expr: "(" tuple_element? ("," tuple_element)* ")"

?tuple_element: add_tuple_element
              | sub_tuple_element
              | atomic_tuple_element

add_tuple_element: tuple_element "+" atomic_tuple_element

sub_tuple_element: tuple_element "-" atomic_tuple_element

?atomic_tuple_element: UNDEF -> undef
                      | tuple_element_literal
                      | tuple_element_ref
                      | functor_call
                      | bracketed_tuple_element
                      | record_tuple_element

functor_call: ( userdef_functor | INTRINSIC_FUNCTOR ) "(" tuple_element ("," tuple_element)* ")"

bracketed_tuple_element: "(" tuple_element ")"

record_tuple_element: "PACK" "(" tuple_element ("," tuple_element)* ")"

// NOTE: incomplete, add more as they are discovered
tuple_element_literal: "string" "(" STRING ")"
                       | "NUMBER" "(" NUMBER ")"

ram_relname: RELKIND? qualified_name

/// main

main: "BEGIN MAIN" call* "END MAIN"

?call: "CALL" IDENT

/// building blocks

userdef_functor: "@" qualified_name

tuple_element_ref: IDENT "." UNSIGNED

attribute: qualified_name ":" TYPE_FINGERPRINT ":" typename

qualified_name: IDENT ("." IDENT)*

typename: "number" | "symbol" | "unsigned" | "float" | qualified_name

/// json parser, with strings escaped. some fields are given in this weird json syntax.

?json: object
       | array
       | EMBEDDED_STRING    -> string
       | NUMBER             -> number
       | "true"             -> true
       | "false"            -> false
       | "null"             -> null

array: "[" [json ("," json)*] "]"

object: "{" [pair ("," pair)*] "}"

pair: EMBEDDED_STRING ":" json

/// tokens

INTRINSIC_FUNCTOR: "ord" | "to_float" | "to_number" | "to_string" | "to_unsigned" | "cat" | "strlen" | "substr" | "autoinc" | "min"


EMBEDDED_STRING: /\\\"[^"]*\\\"/

IO_OPT_NAME: "IO"
             | "attributeNames"
             | "auxArity"
             | "delimiter"
             | "fact-dir"
             | "output-dir"
             | "filename"
             | "name"
             | "operation"
             | "params"
             | "types"

// NOTE: Not sure not equals is correct
COMPARATOR: "<="
             | ">="
             | "<"
             | ">"
             | "="
             | "!="

AGGREGATOR: "max"
            | "mean"
            | "min"
            | "sum"
            | "count"

UNDEF: /UNDEF/

RELKIND: /@new_|@delta_|\+/

BREAK: "BREAK"

IO_METHOD: "file" | "sqlite" | "stdin"

IO_OP: "input" | "output"

TYPE_FINGERPRINT: /[uisr+]/

%import common.CNAME -> IDENT
%import common.INT -> UNSIGNED
%import common.SIGNED_INT -> NUMBER
%import common.SIGNED_FLOAT -> FLOAT
%import common.ESCAPED_STRING -> STRING

%import common.WS
%import common.CPP_COMMENT
%import common.C_COMMENT

%ignore WS
%ignore CPP_COMMENT
%ignore C_COMMENT
