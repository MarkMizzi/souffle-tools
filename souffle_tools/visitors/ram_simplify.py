from lark.lexer import Token
from lark.tree import Tree
from lark.visitors import Transformer


class RAMSimplifier(Transformer):
    """
    By default the RAM generated by Souffle compiler has lots of redundant brackets, etc.
    We aim to remove these here, allowing for better readability.
    """

    @staticmethod
    def _unwrap_bracketed_cond(tree: Tree) -> None | Tree:
        if tree.data == "bracketed_cond":
            return tree.children[0]
        return None

    @staticmethod
    def _is_atomic_cond(tree) -> bool:
        return tree.data in [
            "in_cond",
            "exists_cond",
            "isempty_cond",
            "comparision",
            "bracketed_cond",
        ]

    @classmethod
    def _is_not_cond(cls, tree) -> bool:
        return tree.data == "not_cond" or cls._is_atomic_cond(tree)

    @classmethod
    def _is_and_cond(cls, tree) -> bool:
        return tree.data == "and_cond" or cls._is_not_cond(tree)

    @classmethod
    def _is_or_cond(cls, tree) -> bool:
        return tree.data == "or_cond" or cls._is_and_cond(tree)

    def bracketed_cond(self, args):
        # an atomic condition has the highest precedence, we don't need to bracket it.
        if self._is_atomic_cond(args[0]):
            return args[0]
        else:
            return Tree("bracketed_cond", args)

    def not_cond(self, args):
        atomic_cond = args[0]
        if atomic_cond.data == "comparision":
            comparator = str(atomic_cond.children[1])

            if comparator == "=":
                atomic_cond.children[1] = Token("COMPARATOR", "!=")
                return Tree("comparision", atomic_cond.children)
            elif comparator == "!=":
                atomic_cond.children[1] = Token("COMPARATOR", "=")
                return Tree("comparision", atomic_cond.children)

        return Tree("not_cond", args)

    def and_cond(self, args):
        rop = args[1]
        subcond = self._unwrap_bracketed_cond(rop)
        if subcond and self._is_not_cond(subcond):
            args[1] = subcond

        lop = args[0]
        subcond = self._unwrap_bracketed_cond(lop)
        if subcond and self._is_and_cond(subcond):
            args[0] = subcond

        return Tree("and_cond", args)

    def or_cond(self, args):
        rop = args[1]
        subcond = self._unwrap_bracketed_cond(rop)
        if subcond and self._is_and_cond(subcond):
            args[1] = subcond

        lop = args[0]
        subcond = self._unwrap_bracketed_cond(lop)
        if subcond and self._is_or_cond(subcond):
            args[0] = subcond

        return Tree("or_cond", args)

    def exit_stmt(self, args):
        args[0] = self._unwrap_bracketed_cond(args[0]) or args[0]
        return Tree("exit_stmt", args)

    def if_stmt(self, args):
        args[0] = self._unwrap_bracketed_cond(args[0]) or args[0]
        return Tree("if_stmt", args)

    def on_index(self, args):
        args[0] = self._unwrap_bracketed_cond(args[0]) or args[0]
        return Tree("on_index", args)
